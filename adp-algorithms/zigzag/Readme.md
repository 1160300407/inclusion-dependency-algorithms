Zigzag
======

Zigzag now works with an arbitrary amount of tables, by filtering all invalid INDs, but the complexity of the optimistic border generation is too high.

## Implementation
* Set operations are used for all the hypergraph operations
* One node inside the hypergraph is always a Set<InclusionDependency>, a set of *unary* INDs. There are combined to build higher arity INDs with set operations.
* The validation-strategy package is used. Zigzag needs an error margin validation in the g3 method.
* Unary IND input is used and then the first k levels of the hypergraph are generated by checking every IND with the validation strategy.

## Bottleneck
The generation of the optimistic border takes forever if there are many unsatisfied INDs. Using Zigzag over more than 2 tables generates many unsatisfied (invalid) INDs. Also see *implications* below.
To reduce the number of invalid INDs, we can limit the following:
* Use only two tables. Prevents invalid INDs with multiple tables per side.
* One table provides only dependants, the other only referenced. Prevents invalid INDs with multiple tables per side.
* Only allow one column to be part of one IND. Prevents invalid: A->B, A->C => AA->BC

To reduce the generation time of the optimistic border, another algorithm could be used, which is not relying on the cartesianProduct for all unsatisfied INDs. Explore minimal transversal algorithms like the paper mentions. This could require performing operations on a graph structure.

## To-Dos
* Provide multiple validation strategies which also calculate the error marging. Ideally a wrapper is used turning each query into a error marging query.
* Replace the generation of the first k levels of INDs with an IND input that returns more than only unary INDs.
* Epsilon right now is set to 1. A fitting value should be explored.

## Implications
Zigzag generates a graph from the unary INDs it gets. This means that with the unary INDs the graph is already predetermined.
This means the unary INDs could generate INDs that will never be satisfied/valid. This includes:
#### Problems:
1. INDs inside the same table => For 2 or more tables this will generate INDs with multiple tables on one side
2. INDs between tables, where INDs of one table can be both dependant and referenced => Multiple tables on one side
3. INDs between tables, where one IND is both dependant and referenced => Multiple tables on one side + same column on 2 sides: AC <= DA
4. INDs between tables, where one IND is part of >=2 INDs => Duplicate columns on one side, e.g. ABC <= DDE

#### Solutions:
1. Filterd out on generation of unary IND Map (dep -> ref) with _notInTheSameTable_
2. Added to unsatisfied on IND check with _hasMultipleTablesPerSide_
3. Added to unsatisfied on IND check with _hasMultipleTablesPerSide_
4. Added to unsatisfied (as in the paper) on IND check with _hasDuplicates_
